#include <iterator>
#include <limits>
#include <vector>
#include <algorithm>

#include <gtest/gtest.h>

using std::vector;
using std::cout, std::endl;


template<typename It>
int operations(It begin, It end, int dir) {
    for (auto p = begin; p != end; p+=dir) {
        std::cout << *p << ", ";
    }
    std::cout << std::endl;

    auto it = begin;
    auto _end = end;
    int last = *it;
    int count = 0;
    it+=dir;


    for (;it != _end;) {
        if (*it == last) {
            // replace this one instead of the last
            ++count;
            it+=dir;
        }
        else if (*it - last != dir) {
            // replace the last element
            ++count;
            _end-=dir;
        }
        else {
            it+=dir;
        }
        last += dir;
    }

    std::cout << "count = " << count <<std::endl;

    return count;
}

int operations_from_median(vector<int>& nums) {
    const int half_length = nums.size() / 2;
    const int left = operations(nums.begin()+half_length, nums.begin()-1, -1);
    const int right = operations(nums.begin()+half_length, nums.end(), 1);

    cout << "left = " << left
        << ", right = " << right << endl;

    return left+right;
}


template<typename It>
std::tuple<int, It> find_operations_for_index(It begin, It end, int index, int cost) {
    const int to_find = *(begin+index) + cost;

    const auto edge = std::upper_bound(begin+index, end, to_find);
    if (edge == end) return {index, end};

    return {index + std::distance(edge, end), edge};
}

int minOperations(vector<int>& nums) {

    if (nums.size() < 2) return 0;

    std::sort(nums.begin(), nums.end());

    // from hint 2: for each index, search possible end (from .size() - 1 == max - min)
    int min_ops = std::numeric_limits<int>::max();
    const auto cost = nums.size() - 1;

    for (int index = 0; index < nums.size(); ++index) {
        // if we go too far, we can't finish the task (and might get non-sensical results)
        if (nums.back() - nums[index] < cost-1) break;

        // get num of operations for this index
        auto [ops, edge] = find_operations_for_index(nums.begin(), nums.end(), index, cost);

        // and update values, if a better solution is found
        if (ops < min_ops) {

            // deduplicate
            for(auto it = nums.begin() + index + 1; it != edge; ++it) {
                if (*(it - 1)  == *it)
                    ++ops;
            }
            if (ops < min_ops)
                min_ops = ops;
        }
    }

    return min_ops;
}

void test(vector<int> nums, int expected) {
    ASSERT_EQ(minOperations(nums), expected);
}

TEST(Test23_10_10, Case1) {
    test({4,2,5,3}, 0);
}
TEST(Test23_10_10, Case2) {
    test({1,2,3,5,6}, 1);
}
TEST(Test23_10_10, Case3) {
    test({1,10,100,1000}, 3);
}
TEST(Test23_10_10, Case4) {
    test({41,33,29,33,35,26,47,24,18,28}, 5);
}
TEST(Test23_10_10, Case5) {
    test({44,28,33,49,4,2,35,28,25,38,47,20,14,30,27,38,42,14,34}, 10);
}
TEST(Test23_10_10, Case6) {
    test({11,44,25,49,40,41,6,9,49,4,47,12,32,49,26,30,2,23,17}, 12);
}
TEST(Test23_10_10, Case7) {
    test({3392,8634,7525,4606,3885,5306,9932,8042,6797,4381,4473,7423,5229,1377,1373,358,1648,4072,895,8689,8522,360,6582,1324,1511,147,6436,1237,8160,5335,9044,9753,9618,5901,460,4100,7514,5081,8677,6568,524,4968,4339,5985,6996,3448,8681,913,5710,3305,1007,6388,6899,7419,4417,5076,3797,7098,5722,6432,4500,5257,3523,6883,9057,2097,9495,324,7254,2805,5115,7915,2827,8654,2621,9651,8450,6530,8967,1178,3917,6984,1616,9276,4907,6654,2998,7404,5922,8581,3015,8796,6074,2350,8499,6846,5607,3420,1684,4434,7565,6171,7447,3538,2038,4572,9020,4130,9456,220,9634,4713,5342,3206,5574,3589,806,2960,5558,3262,4888,4365,3683,5165,4783,2229,4031,1311,1951,719,1677,4818,6688,4825,518,7429,3260,979,7522,8179,4943,9600,9217,545,8037,22,1718,3985,4537,7961,7278,3418,4200,5562,6840,9102,6501,285,4169,1119,8396,8823,1685,6526,8125,8599,2267,2454,3131,2658,468,4165,2397,632,7038,8775,6450,6373,5625,687,7293,8642,5517,3709,1940,4519,5414,8461,8935,1383,1940,8398,7557,3689,6506,1103,6825,2453,3237,4612,9765,4400,4698,6474,6897,9540,4290,1364,6867,2071,9911,6343,6678,802,5800,452,3062,8295,8154,2124,2686,5554,4903,9018,3098,4543,2573,7626,8205,8722,9978,9507,7903,2846,6686,4307,2989,3924,9613,9924,7625,4475,9026,2305,9327,9756,1851,7967,9340,6840,113,2797,7060,8673,4716,2455,3680,8032,8558,67,7089,4167,1941,3555,6948,4549,8728,3938,8567,460,4299,3034,1745,6901,5307,524,5270,84,4016,1154,6220,2398,2701,9559,5274,3122,1361,7477,8685,1820,6153,812,9967,9396,2374,4722,7849,9991,6606,7083,9,891,7549,6771,9137,8295,9775,474,5608,8151,788,4530,982,60,7385,9822,6913,5477,430,615,3479,6955,7402,4325,1914,4060,7967,6747,2754,5532,4341,951,9232,7925,3471,3565,823,3549,7083,266,3542,7859,8719,9066,3178,2377,5582,1903,2984,3294,4661,6924,4404,7774,3757,4093,1540,6171,9850,2179,2680,5270,9730,4479,6767}, 341);
}
TEST(Test23_10_10, Case8) {
    test({7589,1270,2304,5117,8054,553,9083,4659,9297,8299,9815,3000,9836,1055,2814,4756,4956,5317,9376,9952,2058,3048,4320,6698,841,379,6970,4662,1513,2610,7796,3061,9808,9742,5966,6693,8252,3575,4180,5606,530,8178,9572,9740,4600,8662,6923,4723,8040,8794,7055,6851,2324,1904,318,6267,2231,4560,9436,2597,723,6077,656,7759,8665,3557,7867,6642,4087,1720,1521,8251,8936,3370,8033,8044,4555,2385,9282,9622,9959,7091,5924,1014,1775,1711,1948,3363,4214,714,2210,7793,8779,9925,9848,6347,8944,7594,9914,175,3500,1053,1864,9893,1588,7945,9616,5863,45,4035,5218,1956,41,4934,3986,4517,8774,9636,9545,501,666,8280,3572,974,3548,1571,8977,8076,8911,6307,9752,5799,4519,1221,3447,9310,4571,8817,7547,4166,6062,2837,7905,1725,4574,7212,9383,8406,1336,6376,1007,6198,7706,5185,9859,4394,3078,1999,1879,672,7288,5006,9339,1898,7784,7104,4763,5984,3944,9142,4456,1675,747,1808,360,2151,9880,7659,2446,7250,4870,5801,6842,574,2646,5973,7412,5110,889,9236,8690,4768,7082,6473,639,7018,363,2799,2869,1076,7017,6048,3340,8903,4781,3460,7065,3608,4464,886,8249,3308,9054,9657,6555,2150,9837,6547,4462,7507,9094,9121,1889,9272,3962,9376,144,794,9713,7570,3079,4835,4135,8334,512,4072,8072,3961,8765,69,3975,4074,1762,1253,1648,3676,8413,8070,9222,7727,1174,7400,4429,6331,3348,856,68,6156,1282,3627,5407,9178,6350,8597,1367,3253,4889,7781,7215,6340,3325,6009,4449,6103,2522,4131,6185,7100,1849,934,1658,3322,564,3735,8605,1408,6159,8088,3198,9843,1180,2120,418,2083,7990,3278,7111,8863,7241,44,2635,7508,9772,9831,9087,7461,5763,7284,3931,153,5243,4022,4452,8184,9420,5757,1643,7474,349,4525,9999,5719,8681,8450,6981,3409,8081,5857,4524,7455,6946,9189,4890,4973,3133,40,4366,6219,2707,8039,1214,386,6173,7091,5530,786,5715,4352,2119,7089,520,4744,6767,7088,9688,3919,9845,3016,7462,2250,1746,8454,7194,2032,6069,6079,808,7670,1071,4281,728,3638,6015,2492,3921,1684,2623,9814,6003,9421,4167,3612,3831,8308,7567},
            358);
}
TEST(Test23_10_10, Case9) {
    test({1}, 0);
}

